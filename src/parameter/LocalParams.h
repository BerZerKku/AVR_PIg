/*
 * LocalParams.h
 *
 *  Created on: 25.03.2015
 *      Author: Shcheblykin
 */

#ifndef LOCALPARAMS_H_
#define LOCALPARAMS_H_

#include "param.h"

class LocalParams
{
    /// Максимальное количество параметров в списке.
    static const uint8_t MAX_NUM_OF_PARAMS = 25;

    /// Максимальное количество байт для битовых переменных.
    //	static const uint8_t MAX_BUF_BITS_VALUES = 12;

public:
    /// Текущее состояние значения параметра
    enum STATE
    {
        STATE_NO_ERROR = 0,  ///< Значение корректно.
        STATE_READ_PARAM,    ///< Идет считывание параметра.
        STATE_ERROR          ///< Значение ошибочное.
    };

    /// Конструктор
    LocalParams();

    /** Установка нового значения параметра и его проверка на корректность.
     *
     * 	@param val Новое значение параметра.
     */
    void setValue(int16_t val);

    /**	Возвращает текущее значение параметра.
     *
     *	Если текущий параметр битовый (\a Param::PARAM_BITES), то возвращается
     *	значение 0 или 1 для текущего под.номера \a currSameParam. Иначе
     *	возвращается текущее значение параметра.
     *
     * 	@return Текущее значение параметра.
     */
    int16_t getValue() const;

    /**	Возвращает текущий байт для битовых параметров.
     *
     * 	@return Текущий байт для битового параметра.
     */
    uint8_t getValueB() const;

    /**	Возвращает текущее состояние параметра.
     *
     * 	@retval True Ошибочное значение.
     * 	@retval False Корректное значение.
     */
    STATE getState() { return state; }

    /**	Переход к следующему параметру.
     *
     * 	Если достигли конца списка, происходит прыжок на первый параметр.
     * 	Если был осуществлен переход (кол-во параметров больше 1), то ждем
     * 	считывания значения параметра.
     *
     * 	Если параметр был изменен, то устаналивается флаг обновления \a refresh.
     */
    void nextParam();

    /**	Переход к предыдущему параметру.
     *
     * 	Если достигли начала списка, происходит прыжок на последний параметр.
     * 	Если был осуществлен переход (кол-во параметров больше 1), то ждем
     * 	считывания значения параметра.
     *
     * 	Если параметр был изменен, то устаналивается флаг обновления \a refresh.
     */
    void prevParam();

    /** Переход к следующему однотипному параметру.
     *
     *	Если достигли конца списка , происходит прыжок на первый параметр.
     * 	Если был осуществлен переход (кол-во однотипных параметров больше 1),
     * 	то ждем считывания значения параметра.
     */
    void nextSameParam();

    /** Переход к предыдущему однотипному параметру.
     *
     *	Если достигли начала списка, происходит прыжок на последний параметр.
     *	Если был осуществлен переход (кол-во однотипных параметров больше 1),
     * 	то ждем считывания значения параметра.
     */
    void prevSameParam();

    /** Добавление в список нового параметра.
     *
     * 	В случае переполнения буфера параметров, будет возвращена ошибка.
     *
     * 	@param *newParam Указатель на структуру параметра.
     * 	@retval True Параметр добавлен.
     * 	@retval False Буфер переполнен, параметр небыл добавлен.
     *
     */
    bool addParam(eGB_PARAM newParam);

    /**	Очистка списка параметров.
     *
     * 	По умолчанию устанавливается первый параметр из списка
     * 	\a GB_PARAM_TIME_SYNCH, при этом количество параметров обнуляется.
     */
    void clearParams();

    /**	Возвращает минимальное значение параметра.
     *
     * 	@return Минимальное значение параметра.
     */
    int16_t getMin() const { return pgm_read_word(&getPtrParam()->min); }

    /**	Возвращает максимальное значение параметра.
     *
     *	Для строковых параметров, в максимуме которых хранится кол-во элементов
     *	списка, будет возвращено значение максимального значения с учетом
     *	минимального max = min + flash_max - 1.
     *
     * 	@return Максимальное значение параметра.
     */
    int16_t getMax() const;

    /**	Возвращает дискретность параметра ?!
     *
     * 	@param Дискретность параметра.
     */
    uint8_t getDisc() const { return pgm_read_byte(&getPtrParam()->disc); }

    /**	Возвращает множитель параметра.
     *
     * 	@param Множитель параметра.
     */
    uint8_t getFract() const { return pgm_read_byte(&getPtrParam()->fract); }

    /**	Возвращает номер текущего параметра.
     *
     * 	@return Номер текущего параметра.
     */
    uint8_t getNumOfCurrParam() const { return currParam + 1; }

    /**	Возвращает количество текущих параметров.
     *
     * 	@return Количество текущих параметров.
     */
    uint8_t getNumOfParams() const { return numOfParams; }

    /**	Возвращает указатель на сторку с названием параметра.
     *
     * 	Строка находится во FLASH.
     *
     * 	@return Указатель на строку с названием параметра.
     *
     */
    PGM_P getNameOfParam() const { return (PGM_P) getPtrParam()->name; }

    /**	Возвращает указатель на первую строку массива значений параметра.
     *
     * 	Актуально для переменных значение которых выбирается из списка. Сам
     * 	список находится во FLASH.
     *
     * 	@return Указатель на первую строку массива значений параметра.
     *
     */
    PGM_P getListOfValues() const { return (PGM_P) pgm_read_word(&getPtrParam()->listValues); }

    /**	Возвращает текущий номер однотипного параметра начиная с 1.
     *
     * 	Если номер текущего параметра превышает максимальное количество, будет
     * 	возвращен максимум.
     *
     * 	@return Текущий номер однотипного параметра.
     */
    uint8_t getNumOfCurrSameParam() const;

    /**	Возвращает количество однотипных парметров.
     *
     * 	Например, если для каждой из команд возможно установить свое значение
     * 	"Длительность команды", то тут будет количество команд.
     *
     * 	@return Количество однотипных параметров.
     */
    uint8_t getNumOfSameParams() const;

    /**	Возвращает тип текущего параметра.
     *
     * 	@return Тип текущего параметра.
     */
    Param::PARAM_TYPE getParamType() const
    {
        return (Param::PARAM_TYPE) pgm_read_byte(&getPtrParam()->param);
    }

    /**	Возвращает тип диапазона значений декущего параметра.
     *
     * 	@return Тип диапазона значений текущего параметра.
     */
    Param::RANGE_TYPE getRangeType() const
    {
        return (Param::RANGE_TYPE) pgm_read_byte(&getPtrParam()->range);
    }

    /**	Возвращает размерность текущего параметра.
     *
     * 	@return Размерность текущего параметра.
     */
    Param::DIMENSION getDim() const
    {
        return (Param::DIMENSION) pgm_read_byte(&getPtrParam()->dim);
    }

    /**	Возвращает команду стандартного протокола для текущего параметра.
     *
     * 	@return Команда стандартного протокола для текущего параметра.
     */
    eGB_COM getCom() const { return (eGB_COM) pgm_read_byte(&getPtrParam()->com); }

    /**	Возвращает тип параметра для сохранения нового значения.
     *
     * 	@return Тип параметра для сохранения нового значения.
     */
    eGB_SEND_TYPE getSendType() const
    {
        return (eGB_SEND_TYPE) pgm_read_byte(&getPtrParam()->send);
    }

    /**	Возвращает значение байта доп. информации для сохранения нового значения.
     *
     *	Для параметров, количество которых не постоянно (зависит например от
     *	количества команд на передачу) возвращается сумма байта доп.информации и
     *	текущего номера повторения.
     *
     * 	@return Значение байта доп. информации для сохранения нового значения.
     */
    uint8_t getSendDop() const;

    /**	Установка массива значений параметров.
     *
     * 	Сам массив находится во FLASH, но это учитывается далее.
     *
     * 	@param *ptr Указатель на массив значений параметров.
     */
    void setFlashParams(const Param** ptr) { fps = ptr; };

    /**	Возвращает текущий параметр.
     *
     * 	@return Текущий параметр.
     */
    eGB_PARAM getParam() const { return param[currParam]; }

    /**	Возвращает зависимость повторений текущего параметра.
     *
     * 	@return Зависимость текущего параметра.
     */
    Param::DEPEND_SAME getDependSame() const
    {
        return (Param::DEPEND_SAME) pgm_read_byte(&getPtrParam()->dependSame);
    }

    /**	Возвращает зависимость максимума текущего параметра.
     *
     * 	@return Зависимость текущего параметра.
     */
    Param::DEPEND_MAX getDependMax() const
    {
        return (Param::DEPEND_MAX) pgm_read_byte(&getPtrParam()->dependMax);
    }

    /** Установка кол-ва команд на передачу.
     *
     * 	@param numComPrd Кол-во команд на передачу.
     */
    void setNumComPrd(uint8_t numComPrd) { this->numComPrd = numComPrd; }

    /** Установка кол-ва команд на приеме.
     *
     * 	@param numComPrd Кол-во команд на приеме.
     */
    void setNumComPrm(uint8_t numComPrm) { this->numComPrm = numComPrm; }

    /**	Установка количества аппаратов в линии
     *
     * 	@param numDevices Количество аппаратов в линии
     * 	@argval 2
     * 	@argval 3
     */
    void setNumDevices(uint8_t numDevices) { this->numDevices = numDevices; }

    /**	Возвращает текущее условие для изменения параметра.
     *
     *	@return Условие для изменения параметра.
     */
    Param::CHANGE_COND getChangeCond() const
    {
        return (Param::CHANGE_COND) pgm_read_byte(&getPtrParam()->changeCond);
    }

private:
    const Param** fps;  ///< Массив значений параметров.

    eGB_PARAM param[MAX_NUM_OF_PARAMS];  ///< Массив параметров.

    int16_t val;  ///< Значение текущего параметра.

    uint8_t currParam;  ///< Номер текущего параметра.

    uint8_t numOfParams;  ///< Количество параметров в текущем списке.

    uint8_t currSameParam;  ///< Номер текущего однотипного параметра.

    STATE state;  ///< Флаг ошибки в текущем значении.

    uint8_t numComPrm;  ///< Количество команд на приеме.

    uint8_t numComPrd;  ///< Количество команд на передачу.

    uint8_t numDevices;  ///< Количество аппаратов в линии.

    /**	Проверка установленного значения параметра на корректность.
     *
     * 	В случа ошибочного значения в состояние \a state будет записано
     * 	значение STATE_ERROR, если все верно - \a STATE_NO_ERROR.
     *
     *	@see STATE_ERROR
     *	@see STATE_NO_ERROR
     */
    void checkValue();

    /**	Обновление параметра.
     *
     * 	Текущий статус \a state сбрасывается в ожидание чтения STATE_READ_PARAM,
     * 	а значение параметра сбрасывается в 0.
     *
     */
    void refreshParam();

    /**	Возвращает указатель на массив значений текущего параметра.
     *
     * 	@return Указатель на массив значений текущего параметра.
     */
    Param* getPtrParam() const { return (Param*) pgm_read_word(&fps[param[currParam]]); }
};

#endif /* LOCALPARAMS_H_ */
