/*
 * bsp.h
 *
 *  Created on: 23.05.2014
 *      Author: Shcheblykin
 */

#ifndef __PROTOCOL_MODBUS_H_
#define __PROTOCOL_MODBUS_H_

#include <stdint.h> 

#define INLINE __attribute__((always_inline))

#ifdef AVR
#define VOLATILE volatile
#else
#define VOLATILE
#endif

/**	\brief Класс работы с протоколом MODBUS.
 *
 *
 *
 * 	@see MAX_ERRORS
 */
class TProtocolModbus {
private:
	/// Пауза между принятыми байтами, при которой идет сброс на начало приема.
	static const uint16_t DELAY_RESET = 15000;	// лучше кратно 1500
	/// Пауза между принятыми байтами, при которой определяется окончание приема.
	static const uint16_t DELAY_READ = 35000;	// лучше кратно 3500
	/// Максимальное количество регистров доступных для чтения в одном запрсе
	static const uint16_t MAX_NUM_REGISTERS = 32;
	/// Максимальное количество флагов доступных для чтения в одном запросе
	static const uint16_t MAX_NUM_COILS = 256;
	/// Адрес устройства в сети по умолчанию (т.е. ошибка)
	static const uint8_t ADDRESS_ERR = 255;
	/// Минимальный адрес устройства в сети
	static const uint8_t ADDRESS_MIN = 1;
	/// Максимальный адрес устройства в сети
	static const uint8_t ADDRESS_MAX = 247;
public:

	/// Состояния работы протокола
	enum STATE {
		STATE_OFF,			///< Протокол выключен.
		STATE_READ,			///< Идет чтение посылки.
		STATE_READ_ERROR,	///< Ошибка в принятом пакете (1.5мc < пауза < 3.5мс).
		STATE_READ_OK,		///< Посылка принята.
		STATE_WRITE_WAIT,	///< Ожидание нужных данных.
		STATE_WRITE_READY,	///< Посылка готова к отправке
		STATE_WRITE,		///< Идет отправка посылки.
		STATE_ERROR			///< Ошибка в работе протокола.
	};

	/// Команды доступные в данном классе
	enum COM {
		COM_01H_READ_COIL = 0x01,				///< Чтение флагов.
		COM_03H_READ_HOLDING_REGISTER = 0x03,	///< Чтение внутренних регистров.
		COM_05H_WRITE_SINGLE_COIL = 0x05,		///< Запись одного флага.
		COM_06H_WRITE_SINGLE_REGISTER = 0x06,	///< Запись одного внутреннего регистра.
		COM_0FH_WRITE_MULTIPLIE_COILS = 0x0F,	///< Запись группы флагов.
		COM_10H_WRITE_MULITPLIE_REGISTERS = 0x10,///< Запись группы внутренних регистров.
		COM_11H_SLAVE_ID = 0x11, 				///< Чтение ID подчиненного
	};

	/// Коды исключения
	enum EXCEPTION {
		EXCEPTION_01H_ILLEGAL_FUNCTION = 0x01,	///< Код функции не поддерживается
		EXCEPTION_02H_ILLEGAL_DATA_ADR = 0x02,	///< Неверный адрес регистра
		EXCEPTION_03H_ILLEGAL_DATA_VAL = 0x03,	///< Неверное значение поля данных
		EXCEPTION_04H_DEVICE_FAILURE = 0x04,	///< В устройстве произошла ошибка
		EXCEPTION_10H_TEMP_INAC_PARAM = 0x10,	///< Запись по адресу временно невозможна
		EXCEPTION_11H_UNCHANG_PARAM = 0x11		///< Запись по адресу невозможна
	};

	/// Коды ошибок проверки принятого сообщения
	enum CHECK_ERR {
		CHECK_ERR_NO = 0,       ///< Ошибок нет
		CHECK_ERR_ADR_DEVICE,   ///< Ошибка проверки адреса устройства
		CHECK_ERR_CRC,          ///< Ошибка контрольной суммы
		CHECK_ERR_FUNCTION,     ///< Ошибка проверки кода команды
		CHECK_ERR_FUNCTION_DATA	///< Ошибка проверки данных команды
	};

	/**	Контструктор.
	 *
	 * 	@param buf Указатель на буфер данных.
	 * 	@param size Размер буфера данных.
	 */
	TProtocolModbus(uint8_t *buf, uint8_t size);

	/**	Возвращает значение максимального количества регистров доступных для
	 * 	чтения или записи в одной посылке протокола.
	 *
	 * 	@return Значение максимального количества регистров.
	 */
	uint16_t getMaxNumRegisters() const {
		return  MAX_NUM_REGISTERS;
	}

	/**	Возвращает значение максимального количества флагов доступных для
	 * 	чтения или записи в одной посылке протокола.
	 *
	 * 	@return Значение максимального количества флагов.
	 */
	uint16_t getMaxNumCoils() const {
		return  MAX_NUM_COILS;
	}

	/**	Возвращает адрес устройтсва в протоколе по-умолчанию, т.е. ошибка.
	 *
	 * 	@return Адрес устройства - ошибка.
	 */
	uint8_t getAddressError() const {
		return ADDRESS_ERR;
	}

	/**	Возвращает минимальный адрес устройства, доступный в протоколе.
	 *
	 * 	@return Адрес устройства - минимальный.
	 */
	uint8_t getAddressMin() const {
		return ADDRESS_MIN;
	}

	/**	Возвращает максимальный адрес устройства, досупный в протоколе.
	 *
	 * 	@return Адрес устройства - максимальный.
	 */
	uint8_t getAddressMax() const {
		return ADDRESS_MAX;
	}

	/**	Запуск работы данного протокола.
	 *
	 *	Протокол будет включен в состоянии "Чтение".
	 *	В случае ошибочного значения, протокол останется в текущем состоянии.
	 *
	 *	@see STATE
	 * 	@param state Начальное состояние протокола.
	 */
	void setEnable() {
		setState(STATE_READ);
	}

	/**	Остановка работы данного протокола.
	 *
	 */
	void setDisable() {
		setState(STATE_OFF);
	}

	/** Проверка текущего состояния работы данного протокола
	 *
	 *	@retval True - если текущее состояние протокола не STATE_OFF.
	 *	@retval False - если протокол отключен, т.е. состояние STATE_OFF.
	 */
	bool isEnable() const {
		return (state_ != STATE_OFF);
	}

	/**	Возвращает текущее состояние работы протокола.
	 *
	 * 	@return Текущее состояние протокола.
	 */
	TProtocolModbus::STATE getState() const {
		return state_;
	}

	/**	Смента состояния работы протокола.
	 *
	 *	В случае ошибочного значения, протокол останется в текущем состоянии.
	 *
	 * 	@param state Новое состояние работы протокола.
	 */
	void setState(TProtocolModbus::STATE state);

	/**	Проверка совпадения нужного состояния с текущим.
	 *
	 * 	@retval True - если протокол в нужном состоянии.
	 * 	@retval False - если состояние протокола отличается от нужного.
	 */
	bool checkState(TProtocolModbus::STATE state) const {
		return (state_ == state);
	}

	/**	Проверка наличия принятой посылки.
	 *
	 * 	@retval True - при наличии принятой посылки.
	 * 	@retval False - при отсутствии принятой посылки
	 */
	bool isReadData() const{
		return (state_ == STATE_READ_OK);
	}

	/**	Принятый байт даннх.
	 *
	 *	При переполнении буфера посылка будет просто проигнорирована.
	 *	Производится сброс счетчика времени, прошедшего с момента прихода
	 *	последнего байта.
	 *
	 *	@param byte Байт данных.
	 *	@return Возвращает кол-во принятых данных в буфере.
	 */
	uint8_t push(uint8_t byte);

	/**	Возвращает стартовый адрес регистра/флага в посылке.
	 *
	 * 	@return Стартовый адрес регистра или флага в принятой посылке.
	 */
	uint16_t getStartAddress() const {
		return startAdr_;
	}

	/**	Возвращает количество регистров/флагов в посылке.
	 *
	 * 	@return Количество регистров/флагов в посылке.
	 */
	uint16_t getNumOfAddress() const {
		return numOfAdr_;
	}

	/** Возвращает кол-во байт в принятой посылке или готовых к отправке.
	 *
	 * 	@return Кол-во байт данных.
	 */
	uint8_t getNumOfBytes() const {
		return cnt_;
	}

	/**	Проверка полученной посылки на соответствие протоколу.
	 *
	 * 	Проверяются:
	 * 	- адрес устройства;
	 * 	- контрольная сумма;
	 * 	- поддерживаемая команда;
	 * 	- корректность данных в принятой команде.
	 *
	 * 	Не проверяются:
	 * 	- корректность адресов регистров и флагов.
	 *
	 *	В случае обнаружения ошибки подготавливется ответ с кодом исключения.
	 *	Иначе в зависимости от кода команды подготавливается подготавливается
	 *	основа для ответа.
	 *
	 *	В ходе проверки статус работы протокола может измениться и это надо
	 *	проверить в основной программе.
	 *
	 * 	@return Статус проверки.
	 * 	@see CHECK_ERR
	 */
	TProtocolModbus::CHECK_ERR checkReadPackage();

	/**	Считывание полученных данных для записи в регистр.
	 *
	 * 	Для того чтобы забрать полученные по протоколу новые значения регистра,
	 * 	необходимо указать его адрес.
	 *
	 * 	@param num Адрес регистра.
	 * 	@return Значение регистра.
	 * 	@retval 0xFFFF - Значение по-умолчанию.
	 */
	uint16_t getRegister(uint16_t adr);

	/**	Считывание полученных данных для записи флага.
	 *
	 * 	Для того чтобы забрать полученные по протоколу нове значения флага,
	 * 	необходимо указать его адрес.
	 *
	 * 	Возвращается байт данных, младший бит соответствует младшему адресу.
	 * 	Где бит равный 1 означает, что надо установить флаг, а 0 - сбросить.
	 *
	 * 	@param num Адрес флага.
	 * 	@return Значения флага.
	 * 	@retval 0 - Сбросить флаг.
	 * 	@retval 1 - Установить флаг.
	 * 	@retval 0xFF - Ошибочный адрес.
	 */
	uint8_t getCoil(uint16_t adr);

	/**	Запись регистра для передачи.
	 *
	 * 	Для передачи значения по протоколу, необходимо указать его адрес.
	 *
	 * 	@param adr Адрес регистра.
	 * 	@param val Значение регистра.
	 * 	@retval True - в случае успешной записи.
	 * 	@retval False - в случае ошибки записи.
	 */
	bool writeRegister(uint16_t adr, uint16_t val);

	/**	Запись флага для передачи.
	 *
	 * 	Для передачи значения по протоколу, необходимо указать его адрес.
	 *
	 * 	Если адрес флага не удовлетворяет запрошенным, то формируется ошибка.
	 *
	 * 	@param adr Адрес флага.
	 * 	@param val Значение флага.
	 * 	@retval True - в случае успешной записи.
	 * 	@retval False - в случае ошибки записи.
	 */
	bool writeCoil(uint16_t adr, bool val);

	/**	Запись группы флагов для передачи.
	 *
	 * 	Для передачи значения по протоколоу, необходимо указать начальный адрес
	 * 	флага в байте данных (т.е. адрес младшего флага в байте данных).
	 *
	 * 	Если ни один из принятых флагов (т.е. их адрес) не удовлетворяет
	 * 	запрошенным, то формируется ошибка.
	 *
	 * 	@param adr Адрес флага.
	 * 	@param val Значение флага.
	 * 	@retval True - в случае успешной записи.
	 * 	@retval False - в случае ошибки записи.
	 */
	bool writeCoils(uint16_t adr, uint8_t val);

	/**	Отправка сообщения.
	 *
	 *	В случае, если состояние отличается от состояния передачи. Количество
	 *	байт данных на передачу будет равно 0.
	 *
	 * 	@return Кол-во байт данных для передачи
	 */
	uint8_t trCom();

	/**	Настройка счетчика времени.
	 *
	 * 	Исходя из полученной скорости работы протокола, наличия контроля
	 * 	четности и кол-ва стоп-битов, а так же частоты вызова функции tick(),
	 * 	рассчитывается шаг счета. При этом учитывается что кол-во "бит данных"
	 * 	всегда 8, а кол-во бит "контроль четности" + "стоп-биты" равно 2.
	 *
	 * 	Например:
	 * 	для скорости  19200 и частоте вызова функции 1 раз в 50мкс, получим:
	 * 	step = (period / 10^6) * (DELAY_RESET / 1.5) * (baudrate / 11) =
	 * 	= (50 / 10^6) * (15000/1.5) * (19200 / 11) = 872
	 *
	 * 	Для частот выше 19200 рекомендуются значения: 750мкс для полуторного
	 * 	интервала, и 1750 для 3.5 интервала. Поэтому шаг счета для вызова раз в
	 * 	50 мкс будет::
	 * 	step = DELAY_RESET * period / 750 = 15000/750 * period = 20 * 50 = 1000
	 *
	 *	@param baudrate Скорость работы последовательного порта, бит/с.
	 *	@param period Частота вызова функции tick(), мкс.
	 *	@return Рассчитанный шаг счетчика.
	 */
	uint16_t setTick(uint16_t baudrate, uint8_t period);

	/**	Счет времени прошедшего с момента прихода последнего байта.
	 *	
	 *	Счетчик считает только в состояниях \a STATE_READ и \a STATE_READ_ERROR.
	 *	
	 *	Как только счетчик времени достигнет (превысит) \a DELAY_READ, т.е.
	 *	будет обнаружена "3.5 пауза":
	 *	- в состоянии \a STATE_READ, формируется состояние принятой посылки
	 *	\a STATE_READ_OK;
	 *	- в состоянии \a STATE_READ_ERROR, формируется состояние приема посылки
	 *	\a STATE_READ (т.е. ожидание новой посылки).
	 *
	 * 	Вызывается с заданным интервалом.  Например, из прерывания.
	 *
	 *	@see DELAY_READ
	 *	@see STATE_READ
	 *	@see STATE_READ_ERROR
	 */
	void tick();

	/**	Установка адреса устройства в сети.
	 *
	 * 	@param adr Адрес устройства.
	 * 	@retval True - в случае смены адреса устройства.
	 * 	@retval False - в случае ошибочного адреса.
	 */
	bool setAddress(uint8_t adr);

	/**	Возвращает адрес устройства в сети.
	 *
	 * 	@return Адрес устройства.
	 */
	uint8_t getAddress() const;

	/**	Ответ на запрос с кодом исключения.
	 *
	 *	К коду принятой команды добавляется 0х80.
	 *	Добавляется один байт данных - код исключения.
	 *	Подсчитывается контрольная сумма.
	 *	Флаг состояния протокола устанавливаетс \a STATE_WRITE, т.е. готовность
	 *	к отправке данных.
	 *
	 *	@param code Код исключения.
	 */
	void setException(TProtocolModbus::EXCEPTION code);

private:
	const uint8_t size_;	///> Размер буфера данных
	uint8_t * const buf_;	///> Буфер принятых/передаваемых данных

	static const uint8_t CRC_HI[256];	///> Массив значений для подсчета CRC
	static const uint8_t CRC_LOW[256];	///> Массив значений для подсчета CRC

	STATE state_;			///> Текущее состояние работы протокола.
	uint8_t address_;		///> Адрес устройства в сети.
	VOLATILE uint8_t cnt_;	///> Кол-во принятых байт.
	VOLATILE uint16_t tick_;///> Время прошедшее с момента приема последнего байта.
	uint16_t tickStep_;		///> Шаг счетчика паузы.
	uint16_t startAdr_;		///> Начальный адрес в запросе
	uint8_t  numOfAdr_;		///> Кол-во адресов в запросе

	// Проверка соответствия принятой команды поддерживаемым в этом классе.
	TProtocolModbus::CHECK_ERR checkCommand(uint8_t com);

	// Проверка адреса устройства на совпадение с установленным.
	bool checkAddress(uint8_t adr);

	// Подсчет CRC для заданного кол-ва байт данных в буфере.
	uint16_t calcCRC(uint8_t num);

	// Возвращает принятый в посылке CRC.
	uint16_t getCRC() const;

	// Добавляет к имеющейся в буфере посылке контрольную сумму.
	void addCRC();

	// Подготовка посылки для ответа на запрос.
	void makeResponse(uint8_t com);
};

#endif /* __PROTOCOL_MODBUS_H_ */
