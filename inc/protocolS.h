/*
 * protocolS.h
 *
 *  Created on: 28.06.2012
 *      Author: Shcheblykin
 */

#ifndef PROTOCOLS_H_
#define PROTOCOLS_H_

enum ePRTS_ACTION
{
	PRTS_READ_COM,
	PRTS_WRITE_COM
};

enum ePRTS_STATUS
{
	PRTS_STATUS_NO = 0,		// состояние по-умолочанию (в том числе ошибочное)
	PRTS_STATUS_READ,		// считана команда, но еще не проверена КС
	PRTS_STATUS_READ_OK,	// считана команда и проверена КС
	PRTS_STATUS_WRITE,		// в буфере есть команда, надо передать
};

class clProtocolS
{

public:
	clProtocolS	(uint8_t *buf, uint8_t size);

//	uint8_t addCom	(uint8_t com, ePRTS_ACTION act);
//	bool getData	(stMNUparam *param);

	// указатель на буфер
	uint8_t * const buf;

	/// Проверка флага наличия принятой посылки
	bool checkReadData();

	/// Сброс флага принятой посылки
//	void clrRdy() { this->rdy = false; this->cnt = 0; }

	/// Запуск работы данного протокола
	void setEnable() { this->enable = true; this->stat = PRTS_STATUS_NO;}

	/// Остановка работы данного протокола
	void setDisable() { this->enable = false; }

	/// Проверка текущего состояния протокола
	bool isEnable() const { return this->enable; }

	/// Отправка сообщения, возвращает длинну передаваемой посылки
	uint8_t trCom() { this->stat = PRTS_STATUS_NO; return this->cnt; }

	/// Текущая команда в буфере
	uint8_t getCurrentCom() const { return this->buf[2]; }

	/// Текущий статус работы протокола
	ePRTS_STATUS getCurrentStatus() const { return this->stat; }

	/// Копирование посылки из другого буфера
	bool copyCommandFrom(uint8_t * const bufSource);

	///
	bool getData();

	/// Проверка принятого байта на соответствие протоколу
	/// возвращает false в случае ошибки
	/// !!! Помещается в прерывание по приему
	bool checkByte(uint8_t byte)
	{
		uint8_t cnt = this->cnt;

		switch(cnt)
		{
		case 0:
			if (byte == 0x55)
				cnt++;
			break;
		case 1:
			cnt = (byte == 0xAA) ? 2 : 0;
			break;
		case 2:
			cnt++;
			break;
		case 3:
			if (byte < (this->size - 5))
			{
				cnt++;
				this->maxLen = byte + 5;
			}
			else
				cnt = 0;
			break;
		default:
			cnt++;
			if (cnt >= this->maxLen)
				this->stat = PRTS_STATUS_READ;
			break;
		}

		this->cnt = cnt;
		return cnt;
	}

private:
	// текущий статус работы протокола
	ePRTS_STATUS stat;

	// Счетчик принятого байта по протоколу
	uint8_t cnt;

	// Заявленное кол-во байт данных в посылке
	uint8_t maxLen;

	// размер буфера
	const uint8_t size;

	// Текущее состояние протокола. true - запущен
	bool enable;

	// Подготовка к отправке команды без данных (заполнение буфера)
	uint8_t addCom	(uint8_t com);
	// Подготовка к отправке команды с 1 байтом данных (заполнение буфера)
	uint8_t addCom	(uint8_t com, uint8_t byte);
	// Подготовка к отправке команды с данными (заполнение буфера)
	uint8_t addCom	(uint8_t com, uint8_t size, const uint8_t * buf);

	// Проверка принятой контрольной суммы
	bool checkCRC();

	// вычисление контрольной суммы содержимого буфера
	uint8_t getCRC();
};


#endif /* PROTOCOLS_H_ */
